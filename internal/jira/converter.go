package jira

import (
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/steveyegge/beads/internal/types"
)

// DefaultStatusMapping maps Jira status names (lowercase) to bd status values.
var DefaultStatusMapping = map[string]types.Status{
	"to do":             types.StatusOpen,
	"todo":              types.StatusOpen,
	"open":              types.StatusOpen,
	"backlog":           types.StatusOpen,
	"new":               types.StatusOpen,
	"in progress":       types.StatusInProgress,
	"in development":    types.StatusInProgress,
	"in review":         types.StatusInProgress,
	"review":            types.StatusInProgress,
	"blocked":           types.StatusBlocked,
	"on hold":           types.StatusBlocked,
	"done":              types.StatusClosed,
	"closed":            types.StatusClosed,
	"resolved":          types.StatusClosed,
	"complete":          types.StatusClosed,
	"completed":         types.StatusClosed,
	"won't do":          types.StatusClosed,
	"won't fix":         types.StatusClosed,
	"duplicate":         types.StatusClosed,
	"cannot reproduce":  types.StatusClosed,
}

// DefaultTypeMapping maps Jira issue type names (lowercase) to bd issue types.
var DefaultTypeMapping = map[string]types.IssueType{
	"bug":            types.TypeBug,
	"defect":         types.TypeBug,
	"story":          types.TypeFeature,
	"feature":        types.TypeFeature,
	"new feature":    types.TypeFeature,
	"improvement":    types.TypeFeature,
	"enhancement":    types.TypeFeature,
	"task":           types.TypeTask,
	"sub-task":       types.TypeTask,
	"subtask":        types.TypeTask,
	"epic":           types.TypeEpic,
	"initiative":     types.TypeEpic,
	"technical task": types.TypeChore,
	"technical debt": types.TypeChore,
	"maintenance":    types.TypeChore,
	"chore":          types.TypeChore,
}

// DefaultPriorityMapping maps Jira priority names (lowercase) to bd priority (0-4).
var DefaultPriorityMapping = map[string]int{
	"highest":  0,
	"critical": 0,
	"blocker":  0,
	"high":     1,
	"major":    1,
	"medium":   2,
	"normal":   2,
	"low":      3,
	"minor":    3,
	"lowest":   4,
	"trivial":  4,
}

// Converter converts Jira issues to bd issues.
type Converter struct {
	jiraURL        string
	prefix         string
	statusMap      map[string]types.Status
	typeMap        map[string]types.IssueType
	priorityMap    map[string]int
	jiraKeyToBDID  map[string]string // Maps Jira keys to bd IDs for dependency resolution
	idGenerator    func(title string, timestamp time.Time) (string, error)
}

// ConverterConfig holds configuration for the converter.
type ConverterConfig struct {
	JiraURL     string
	Prefix      string // ID prefix (default: "bd")
	StatusMap   map[string]types.Status
	TypeMap     map[string]types.IssueType
	PriorityMap map[string]int
	// IDGenerator generates a bd ID. If nil, a simple incrementing ID is used.
	// The function should return an ID in the format "prefix-xxx".
	IDGenerator func(title string, timestamp time.Time) (string, error)
}

// NewConverter creates a new Jira to bd converter.
func NewConverter(cfg ConverterConfig) *Converter {
	prefix := cfg.Prefix
	if prefix == "" {
		prefix = "bd"
	}

	statusMap := cfg.StatusMap
	if statusMap == nil {
		statusMap = DefaultStatusMapping
	}

	typeMap := cfg.TypeMap
	if typeMap == nil {
		typeMap = DefaultTypeMapping
	}

	priorityMap := cfg.PriorityMap
	if priorityMap == nil {
		priorityMap = DefaultPriorityMapping
	}

	return &Converter{
		jiraURL:       strings.TrimSuffix(cfg.JiraURL, "/"),
		prefix:        prefix,
		statusMap:     statusMap,
		typeMap:       typeMap,
		priorityMap:   priorityMap,
		jiraKeyToBDID: make(map[string]string),
		idGenerator:   cfg.IDGenerator,
	}
}

// Convert transforms a slice of Jira issues into bd issues.
// Returns the converted issues and any dependencies discovered.
func (c *Converter) Convert(jiraIssues []*JiraIssue) ([]*types.Issue, error) {
	// First pass: convert all issues and build key-to-ID mapping
	bdIssues := make([]*types.Issue, 0, len(jiraIssues))

	counter := 1 // Fallback counter if no ID generator provided

	for _, jira := range jiraIssues {
		bdIssue, err := c.convertIssue(jira, &counter)
		if err != nil {
			return nil, fmt.Errorf("converting issue %s: %w", jira.Key, err)
		}
		c.jiraKeyToBDID[jira.Key] = bdIssue.ID
		bdIssues = append(bdIssues, bdIssue)
	}

	// Second pass: resolve dependencies
	for i, jira := range jiraIssues {
		deps := c.extractDependencies(jira)
		if len(deps) > 0 {
			bdIssues[i].Dependencies = deps
		}
	}

	return bdIssues, nil
}

// convertIssue converts a single Jira issue to a bd issue.
// If IDGenerator is nil, ID is left empty and must be generated by the import logic.
func (c *Converter) convertIssue(jira *JiraIssue, counter *int) (*types.Issue, error) {
	// Parse timestamps
	createdAt, err := parseJiraTimestamp(jira.Fields.Created)
	if err != nil {
		createdAt = time.Now()
	}

	updatedAt, err := parseJiraTimestamp(jira.Fields.Updated)
	if err != nil {
		updatedAt = createdAt
	}

	// Generate ID if generator is provided, otherwise leave empty for import logic
	var id string
	if c.idGenerator != nil {
		id, err = c.idGenerator(jira.Fields.Summary, createdAt)
		if err != nil {
			return nil, fmt.Errorf("generating ID: %w", err)
		}
	} else if c.prefix != "" {
		// Use simple sequential IDs as placeholders - import logic will regenerate
		id = fmt.Sprintf("%s-%d", c.prefix, *counter)
		*counter++
	}
	// If both are nil/empty, ID will be generated by import logic

	// Map fields
	status := c.mapStatus(jira.Fields.Status)
	issueType := c.mapIssueType(jira.Fields.IssueType)
	priority := c.mapPriority(jira.Fields.Priority)

	// Build external reference URL
	externalRef := fmt.Sprintf("%s/browse/%s", c.jiraURL, jira.Key)

	// Get reporter/creator
	createdBy := ""
	if jira.Fields.Reporter != nil {
		createdBy = jira.Fields.Reporter.GetDisplayName()
	}

	issue := &types.Issue{
		ID:          id,
		Title:       jira.Fields.Summary,
		Description: jira.Fields.GetDescription(),
		Status:      status,
		Priority:    priority,
		IssueType:   issueType,
		CreatedAt:   createdAt,
		CreatedBy:   createdBy,
		UpdatedAt:   updatedAt,
		ExternalRef: &externalRef,
		Labels:      jira.Fields.Labels,
	}

	// Set assignee
	if jira.Fields.Assignee != nil {
		issue.Assignee = jira.Fields.Assignee.GetDisplayName()
	}

	// Set closed_at if resolved
	if status == types.StatusClosed && jira.Fields.ResolutionDate != "" {
		closedAt, err := parseJiraTimestamp(jira.Fields.ResolutionDate)
		if err == nil {
			issue.ClosedAt = &closedAt
		}
	}

	return issue, nil
}

// extractDependencies extracts bd dependencies from Jira issue links.
func (c *Converter) extractDependencies(jira *JiraIssue) []*types.Dependency {
	var deps []*types.Dependency
	bdID := c.jiraKeyToBDID[jira.Key]

	// Handle issue links
	for _, link := range jira.Fields.IssueLinks {
		if link.Type == nil {
			continue
		}

		linkType := strings.ToLower(link.Type.Name)
		var linkedKey string
		var depType types.DependencyType

		if link.InwardIssue != nil {
			linkedKey = link.InwardIssue.Key
			// Inward means the other issue has this relationship TO us
			// e.g., "is blocked by" means linked_key blocks us
			if strings.Contains(linkType, "block") {
				depType = types.DepBlocks
			} else {
				depType = types.DepRelated
			}
		} else if link.OutwardIssue != nil {
			linkedKey = link.OutwardIssue.Key
			// Outward means we have this relationship TO the other issue
			// e.g., "blocks" means we block linked_key
			if strings.Contains(linkType, "block") {
				// Flip: if we block them, they depend on us (not stored as our dep)
				continue
			}
			depType = types.DepRelated
		}

		// Only add if the linked issue was also imported
		linkedBDID, exists := c.jiraKeyToBDID[linkedKey]
		if exists && linkedKey != "" {
			deps = append(deps, &types.Dependency{
				IssueID:     bdID,
				DependsOnID: linkedBDID,
				Type:        depType,
				CreatedAt:   time.Now(),
			})
		}
	}

	// Handle parent (epic link)
	if jira.Fields.Parent != nil {
		parentBDID, exists := c.jiraKeyToBDID[jira.Fields.Parent.Key]
		if exists {
			deps = append(deps, &types.Dependency{
				IssueID:     bdID,
				DependsOnID: parentBDID,
				Type:        types.DepParentChild,
				CreatedAt:   time.Now(),
			})
		}
	}

	return deps
}

// mapStatus maps a Jira status to a bd status.
func (c *Converter) mapStatus(status *JiraStatus) types.Status {
	if status == nil {
		return types.StatusOpen
	}
	name := strings.ToLower(status.Name)
	if bdStatus, ok := c.statusMap[name]; ok {
		return bdStatus
	}
	return types.StatusOpen
}

// mapIssueType maps a Jira issue type to a bd issue type.
func (c *Converter) mapIssueType(issueType *JiraIssueType) types.IssueType {
	if issueType == nil {
		return types.TypeTask
	}
	name := strings.ToLower(issueType.Name)
	if bdType, ok := c.typeMap[name]; ok {
		return bdType
	}
	return types.TypeTask
}

// mapPriority maps a Jira priority to a bd priority.
func (c *Converter) mapPriority(priority *JiraPriority) int {
	if priority == nil {
		return 2 // Default medium
	}
	name := strings.ToLower(priority.Name)
	if bdPriority, ok := c.priorityMap[name]; ok {
		return bdPriority
	}
	return 2
}

// parseJiraTimestamp parses a Jira timestamp string.
// Jira uses ISO 8601 with timezone: 2024-01-15T10:30:00.000+0000 or 2024-01-15T10:30:00.000Z
func parseJiraTimestamp(ts string) (time.Time, error) {
	if ts == "" {
		return time.Time{}, fmt.Errorf("empty timestamp")
	}

	// Handle Z suffix
	if strings.HasSuffix(ts, "Z") {
		ts = ts[:len(ts)-1] + "+00:00"
	}

	// Handle +0000 format (no colon in timezone)
	re := regexp.MustCompile(`([+-]\d{2})(\d{2})$`)
	ts = re.ReplaceAllString(ts, "$1:$2")

	// Try parsing with fractional seconds
	t, err := time.Parse("2006-01-02T15:04:05.000-07:00", ts)
	if err == nil {
		return t, nil
	}

	// Try without fractional seconds
	t, err = time.Parse("2006-01-02T15:04:05-07:00", ts)
	if err == nil {
		return t, nil
	}

	// Try with different fractional second precision
	t, err = time.Parse("2006-01-02T15:04:05.999999999-07:00", ts)
	if err == nil {
		return t, nil
	}

	return time.Time{}, fmt.Errorf("unable to parse timestamp: %s", ts)
}

// GetJiraKeyToBDIDMap returns the mapping from Jira keys to bd IDs.
// Useful for post-conversion operations.
func (c *Converter) GetJiraKeyToBDIDMap() map[string]string {
	result := make(map[string]string, len(c.jiraKeyToBDID))
	for k, v := range c.jiraKeyToBDID {
		result[k] = v
	}
	return result
}
